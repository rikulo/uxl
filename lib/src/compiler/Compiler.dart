//Copyright (C) 2012 Potix Corporation. All Rights Reserved.
//History: Thu, Nov 01, 2012  4:56:10 PM
// Author: tomyeh
part of rikulo_uxl_compile;

/**
 * The UXL compiler.
 */
class Compiler {
  final Document source;
  final OutputStream destination;
  final Encoding encoding;
  _Context _current;
  final Queue<_Context> _ctxes = new Queue();
  //template names
  final Set<String> _templNames = new Set();
  //The additional output that will be appended to the end of [destination]
  //They are typically generated by the templates defined inside the root template
  final List<List<int>> _extraOutput = new List();

  Compiler(this.source, this.destination, {Encoding this.encoding:Encoding.UTF_8});

  void compile() {
    for (final node in source.nodes) {
      if (node is Element && (node as Element).tagName != "Template")
        throw const CompileException("The root element must be <Template>");
      _do(node);
    }
    for (final extra in _extraOutput)
      destination.write(extra);
  }
  void _do(Node node) {
    if (node is Element) {
      _doElement(node);
    } else if (node is ProcessingInstruction) {
      _doPI(node);
    } else {

    }
  }
  void _doElement(Element elem) {
    final name = elem.tagName;
    switch (name) {
      case "Template":
        _doTemplate(elem);
        return;
      case "Apply":
        _doApply(elem);
        return;
    }

    final attrs = elem.attributes;
    var pre = _current.pre;

    final preForEach = pre;
    var forEach = attrs["forEach"];
    if (forEach != null) {
      if (forEach.isEmpty) {
        forEach = null;
        _warning("The forEach attribute is empty");
      } else {
        _writeln("${pre}for (final $forEach) {");
        _current.pre = pre = "$pre  ";
      }
    }

    final preIf = pre;
    var ifc = attrs["if"];
    if (ifc != null) {
      if (ifc.isEmpty) {
        ifc = null;
        _warning("The if attribute is empty");
      } else {
        _writeln("${pre}if ($ifc) {");
        _current.pre = pre = "$pre  ";
      }
    }

    final viewVar = _nextVar(),
      parentVar = _current.parentVar;
    if (_templNames.contains(name)) {
    //create from Template:
    //  new Template(parent: parent, attr: val)..dataAttributes[attr] = val;
      _write("${pre}final $viewVar = current = new $name().create(\n${pre}  parent: ${parentVar!=null?parentVar:'parent'}");

      for (final attr in attrs.keys) {
        if (attr.startsWith("data-")) {
          _warning("Data attributes, $attr, not allowed in a template, $name");
        } else {
          final val = attrs[attr];
          switch (attr) {
          case "forEach": case "if": case "control":
            break; //ignore
          case "layout":
          case "profile":
          case "style":
          case "class":
            _warning("Template doesn't support $attr");
            break;
          default:
            _write(',\n$pre  $attr: ${_outAttrValue(val)}');
            break;
          }
        }
      }

      _writeln(");");
      if (parentVar == null)
        _writeln("${pre}_vcr_.addAll($viewVar);");
      _writeln("");

    } else {
    //Create View:
    // new View()..attr = val..dataAttributes[attr] = val;
      _write("${pre}final $viewVar = current = new $name()");

      for (final attr in attrs.keys) {
        final val = attrs[attr];
        if (attr.startsWith("data-")) {
          _write('\n$pre  ..dataAttributes["${attr.substring(5)}"] = ${_outAttrValue(val)}');
        } else {
          switch (attr) {
          case "forEach": case "if": case "control":
            break; //ignore
          case "layout":
          case "profile":
            _write('\n$pre  ..$attr.text = ${_outAttrValue(val)}');
            break;
          case "style":
            _write('\n$pre  ..$attr.cssText = ${_outAttrValue(val)}');
            break;
          case "class":
            for (final css in val.split(" "))
              _write('\n$pre  ..classes.add("$css")');
            break;
          default:
            _write('\n$pre  ..$attr = ${_outAttrValue(val)}');
            break;
          }
        }
      }
      _writeln(";");

      if (parentVar != null)
        _writeln("$pre$parentVar.addChild($viewVar);\n");
      else
        _writeln("${pre}if (parent != null)\n$pre  parent.addChild($viewVar);\n${pre}_vcr_.add($viewVar);\n");
    }

    _pushContext(parentVar: viewVar);
    _doChildren(elem);
    _popContext();

    if (forEach != null) {
      _current.pre = pre = preForEach;
      _writeln("$pre}\n");
    }
    if (ifc != null) {
      _current.pre = pre = preIf;
      _writeln("$pre}\n");
    }

    final control = attrs["control"];
    if (control != null) {
      if (control.isEmpty) {
        _warning("The control attribute is empty");
      } else {
        _writeln("$pre($control).apply($viewVar);");
      }
    }
  }
  void _doPI(ProcessingInstruction pi) {
    switch (pi.target) {
      case "dart":
        _writeln("");
        _writeln(pi.data);
        break;
      case "template":
        if (!pi.data.isEmpty)
          for (String nm in pi.data.split(' '))
            _templNames.add(nm);
        break;
      default:
        _warning("Unknown <? ${pi.target} ?>");
    }
  }

  //Handles Template
  void _doTemplate(Element elem) {
    ListOutputStream innerOut = _current != null ? new ListOutputStream(): null;
    _pushContext(dest: innerOut);
    final name = _requiredAttr(elem, "name");
    var args = elem.attributes["args"];
    args = args != null && !args.trim().isEmpty ? "parent, $args": "parent";
    _noAttrs(elem, ["if", "unless", "forEach"]);
    _write('''\n
///A template.
class $name {
  ///Creates and returns views defined in this template.
  List<View> create({$args}) {
    List<View> _vcr_ = new List();
    var current;\n''');

    _doChildren(elem);

    _writeln("    return _vcr_;\n  }\n}");
    _popContext();
    if (innerOut != null)
      _extraOutput.add(innerOut.read());
  }

  ///Handles <Apply>
  void _doApply(Element elem) {

  }

  ///Handles child nodes
  void _doChildren(Element elem) {
    for (final node in elem.nodes)
      _do(node);
  }

  //Utilities//
  String _requiredAttr(Element elem, String attr) {
    final val = elem.attributes[attr];
    if (val == null || val.isEmpty)
      throw new CompileException("The $attr attribute is required");
    return val;
  }
  void _noAttrs(Element elem, List<String> attrs) {
    for (final attr in attrs)
      if (elem.attributes[attr] != null)
        _warning("The $attr attribute not allowed");
  }
  String _outAttrValue(String val)
  => val.startsWith("\${") && val.endsWith("}") && val.indexOf("\${", 1) < 0 ?
      val.substring(2, val.length -1): "'''$val'''";

  String _nextVar()
  => "${_current.parentVar != null ? _current.parentVar: '_v'}${_current.nextId++}_";

  void _write(String str) {
    (_current != null ? _current.dest: destination).writeString(str, encoding);
  }
  void _writeln(String str) {
    _write(str);
    _write("\n");
  }
  void _pushContext({OutputStream dest, String parentVar}) {
    _ctxes.addFirst(new _Context(_current, parentVar,
      dest != null ? dest: _current != null ? _current.dest: destination,
      dest == null && _current != null ? _current.pre: "    "));
    _current = _ctxes.first;
  }
  void _popContext() {
    _ctxes.removeFirst();
    _current = _ctxes.isEmpty ? null: _ctxes.first;
  }
}

class _Context {
  final _Context previous;
  final OutputStream dest;
  final parentVar;
  String pre;
  int nextId = 0;

  _Context(_Context this.previous, this.parentVar, this.dest, this.pre);
}

///show warning messages
void _warning(String msg) {
  print("Warning: $msg");
}
