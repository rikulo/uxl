//Copyright (C) 2012 Potix Corporation. All Rights Reserved.
//History: Thu, Nov 01, 2012  4:56:10 PM
// Author: tomyeh
part of rikulo_uxl_compile;

/**
 * The UXL compiler.
 */
class Compiler {
  final Document source;
  final OutputStream destination;
  final Encoding encoding;
  _Context _current;
  final Queue<_Context> _ctxes = new Queue();
  //template names
  final Set<String> _templNames = new Set();
  //The additional output that will be appended to the end of [destination]
  //They are typically generated by the templates defined inside the root template
  final List<List<int>> _extraOutput = new List();

  Compiler(this.source, this.destination, {Encoding this.encoding:Encoding.UTF_8});

  void compile() {
    for (final node in source.nodes) {
      if (node is Element && (node as Element).tagName != "Template")
        throw const CompileException("The root element must be <Template>");
      _do(node);
    }
    for (final extra in _extraOutput)
      destination.write(extra);
  }
  void _do(Node node) {
    if (node is Element) {
      _doElement(node);
    } else if (node is ProcessingInstruction) {
      _doPI(node);
    } else if (node is Text) {
      final text = node.value.trim();
      if (!text.isEmpty)
        _newText(text);
    }
  }
  void _doElement(Element elem) {
    final name = elem.tagName;
    if (name == "Template") {
      _defineTemplate(elem);
      return;
    }

    final attrs = elem.attributes;
    var pre = _current.pre;

    final preForEach = pre;
    var forEach = attrs["forEach"];
    if (forEach != null) {
      if (forEach.isEmpty) {
        forEach = null;
        _warning("The forEach attribute is empty");
      } else {
        _writeln("\n${pre}for (var $forEach) {");
        _current.pre = pre = "$pre  ";
      }
    }

    final preIf = pre;
    var ifc = attrs["if"];
    if (ifc != null) {
      if (ifc.isEmpty) {
        ifc = null;
        _warning("The if attribute is empty");
      } else {
        _writeln("\n${pre}if ($ifc) {");
        _current.pre = pre = "$pre  ";
      }
    }

    if (name == "Apply") {
      _doApply(elem.nodes);
      _checkAttrs(elem, _applyAllowed);
    } else if (_templNames.contains(name)) {
      _newTempalte(name, attrs);
      if (!elem.nodes.isEmpty)
        _warning("$name is a template. It can't have child elements.");
    } else {
      _newView(name, attrs, elem.nodes);
    }

    if (ifc != null) {
      _current.pre = pre = preIf;
      _writeln("$pre}");
    }
    if (forEach != null) {
      _current.pre = pre = preForEach;
      _writeln("$pre}");
    }
  }

  ///Handles processing instructions
  void _doPI(ProcessingInstruction pi) {
    switch (pi.target) {
      case "dart":
        _writeln("");
        _writeln(pi.data);
        break;
      case "template":
        if (!pi.data.isEmpty)
          for (String nm in pi.data.split(' '))
            _templNames.add(nm);
        break;
      default:
        _warning("Unknown <? ${pi.target} ?>");
    }
  }

  //Handles the definition of a template
  void _defineTemplate(Element elem) {
    ListOutputStream innerOut = _current != null ? new ListOutputStream(): null;
    _pushContext(dest: innerOut);
    final name = _requiredAttr(elem, "name");
    var desc = elem.attributes["description"],
      args = elem.attributes["args"];
    if (desc == null)
      desc = "A template to create views.";
    args = args != null && !args.trim().isEmpty ? "parent, $args": "parent";
    _checkAttrs(elem, _templAllowed);
    _writeln('''\n
/** $desc */
List<View> $name({$args}) {
  List<View> _vcr_ = new List();
  var _this_;''');

    for (final node in elem.nodes)
      _do(node);

    _writeln("  return _vcr_;\n}");
    _popContext();
    if (innerOut != null)
      _extraOutput.add(innerOut.read());
  }

  /** Handles the instantiation of a template.
   *
   *    Template(parent: parent, attr: val)..dataAttributes[attr] = val;
   */
  void _newTempalte(String name, Map<String, String> attrs) {
    final viewVar = _nextVar(),
      parentVar = _current.parentVar,
      pre = _current.pre;
    _write("\n${pre}final $viewVar = _this_ =\n${pre}  $name(parent: ${parentVar!=null?parentVar:'parent'}");

    for (final attr in attrs.keys) {
      if (attr.startsWith("data-")) {
        _warning("Data attributes, $attr, not allowed in a template, $name");
      } else {
        final val = attrs[attr];
        switch (attr) {
        case "forEach": case "if":
          break; //ignore
        case "control": //not allowed in template
        case "layout":
        case "profile":
        case "style":
        case "class":
          _warning("Template doesn't support $attr");
          break;
        default:
          _write(', $attr: ${_unwrap(val)}');
          break;
        }
      }
    }

    _writeln(");");
    if (parentVar == null)
      _writeln("${pre}_vcr_.addAll($viewVar);");
  }
  /** Handles the instantiation of a view.
   *
   *    new View()..attr = val..dataAttributes[attr] = val;
   */
  void _newView(String name, Map<String, String> attrs, List<Node> children) {
    final viewVar = _nextVar(),
      parentVar = _current.parentVar,
      pre = _current.pre;
    _write("\n${pre}final $viewVar = _this_ = new $name()");

    for (final attr in attrs.keys) {
      final val = attrs[attr];
      if (attr.startsWith("data-")) {
        _write('\n$pre  ..dataAttributes["${attr.substring(5)}"] = ${_unwrap(val)}');
      } else {
        switch (attr) {
        case "forEach": case "if": case "control":
          break; //ignore
        case "layout":
        case "profile":
          _write('\n$pre  ..$attr.text = ${_unwrap(val)}');
          break;
        case "style":
          _write('\n$pre  ..$attr.cssText = ${_unwrap(val)}');
          break;
        case "class":
          for (final css in val.split(" "))
            _write('\n$pre  ..classes.add("$css")');
          break;
        default:
        //Note: to really handle it well, we have to detect if a field is text.
        //However, it depends on mirrors and UXL files might be compiled before
        //other dart files are ready. It is better to leave it to the users:
        //${foo.toString()} (if they have to convert it)
          if (attr == ':') //passed by _newText to indicate no unwrapping
            _write("\n$pre  ..text = '''$val'''");
          else
            _write('\n$pre  ..$attr = ${_unwrap(val)}');
          break;
        }
      }
    }
    _writeln(";");

    if (parentVar != null)
      _writeln("$pre$parentVar.addChild($viewVar);");
    else
      _writeln('''
${pre}if (parent != null)
$pre  parent.addChild($viewVar);
${pre}_vcr_.add($viewVar);''');

    _pushContext(parentVar: viewVar);
    for (final node in children)
      _do(node);
    _popContext();

    final control = attrs["control"];
    if (control != null) {
      if (control.isEmpty) {
        _warning("The control attribute is empty");
      } else {
        _writeln("${pre}($control)($viewVar);");
      }
    }
  }

  //Handle Text
  void _newText(String text) {
    _newView("TextView", {":": text}, []); //":" to indicate no unwrapping
  }

  //Handle Apply
  void _doApply(List<Node> children) {
    for (final node in children)
      _do(node);
  }

  //Utilities//
  String _requiredAttr(Element elem, String attr) {
    final val = elem.attributes[attr];
    if (val == null || val.isEmpty)
      throw new CompileException("The $attr attribute is required");
    return val;
  }
  void _checkAttrs(Element elem, Set<String> allowedAttrs) {
    for (final attr in elem.attributes.keys)
      if (!allowedAttrs.contains(attr))
        _warning("The $attr attribute not allowed in ${elem.tagName}");
  }
  static final Set<String> _templAllowed =
    new Set.from(const ["name", "args", "description"]);
  static final Set<String> _applyAllowed =
    new Set.from(const ["if", "forEach"]);

  ///Generates the attribute value.
  ///We have to *unwrap* $ if necessary to avoid the string conversion
  String _unwrap(String val) {
    if (val.length > 1 && val[0] == "\$") { //handle ${}
      var cc = val[1],
        len = val.length;
      if (cc == '{') {
        if (val[len - 1] == '}' && val.indexOf("\${", 2) < 0)
          return val.substring(2, len -1);
      } else { //handle $foo
        for (int i = 1;;) {
          if (i >= len)
            return val.substring(1, len);
          cc = val[i++];
          if (!_isLetter(cc) && !_isDigit(cc) && cc != "_" && cc != "\$")
            break;
        }
      }
    }
    return "'''$val'''";
  }

  String _nextVar()
  => "${_current.parentVar != null ? _current.parentVar: '_v'}${_current.nextId++}_";

  void _write(String str) {
    (_current != null ? _current.dest: destination).writeString(str, encoding);
  }
  void _writeln(String str) {
    _write(str);
    _write("\n");
  }
  void _pushContext({OutputStream dest, String parentVar}) {
    _ctxes.addFirst(new _Context(_current, parentVar,
      dest != null ? dest: _current != null ? _current.dest: destination,
      dest == null && _current != null ? _current.pre: "  "));
    _current = _ctxes.first;
  }
  void _popContext() {
    _ctxes.removeFirst();
    _current = _ctxes.isEmpty ? null: _ctxes.first;
  }
}

class _Context {
  final _Context previous;
  final OutputStream dest;
  final parentVar;
  String pre;
  int nextId = 0;

  _Context(_Context this.previous, this.parentVar, this.dest, this.pre);
}

///show warning messages
void _warning(String msg) {
  print("Warning: $msg");
}

//FUTURE: use rikulo-commons instead
const _ZERO = 48, _LOWER_A = 97, _UPPER_A = 65;

bool _isLetter(String char) {
  if (char == null) return false;
  int cc = char.charCodeAt(0);
  return cc >= _LOWER_A && cc < _LOWER_A + 26 || cc >= _UPPER_A && cc < _UPPER_A + 26;
}
bool _isDigit(String char) {
  if (char == null) return false;
  int cc = char.charCodeAt(0);
  return cc >= _ZERO && cc < _ZERO + 10;
}
